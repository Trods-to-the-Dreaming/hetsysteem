{{#block "title"}}Gebouwen beheren{{/block}}

<!------------------------------------------------------------------------------------------------>

{{#block "headScripts"}}
<script type="module">
import { turn } from '/js/turn-check-access.js';

turn.page.key = 'manageBuildings';
turn.page.checkAccess();
</script>
{{/block}}

<!------------------------------------------------------------------------------------------------>

<div id="container-div" class="container-compact d-none">
	<h1>Gebouwen beheren</h1>

	<div id="demolish-div" class="field">
		<h2>üí• Slopen</h2>
		
		<button id="open-demolish-window-button" class="button-2" type="button" 
				data-bs-toggle="offcanvas" data-bs-target="#demolish-window">
			Gebouwen slopen
		</button>
		
		<ul id="demolished-buildings-ul" class="list-compact d-none"></ul>
	</div>
	
	<div id="build-div" class="field">
		<h2>üèóÔ∏è Bouwen</h2>

		<p>Vrije landtegels: <span id="free-tiles-span"></span></p>
		
		<button id="open-construct-window-button" class="button-2" type="button" 
				data-bs-toggle="offcanvas" data-bs-target="#construct-window">
			Nieuw gebouw plaatsen
		</button>
		
		<ul id="new-construction-sites-ul" class="list-compact d-none"></ul>
	</div>
	
	<hr>
</div>

<div id="demolish-window" class="offcanvas offcanvas-start" 
	 data-bs-backdrop="true" data-bs-scroll="false" tabindex="-1">
	<div class="offcanvas-header">
		<h2>Gebouwen slopen</h2>
		
		<button class="btn-close" type="button" data-bs-dismiss="offcanvas"></button>
	</div>
	
	<div class="offcanvas-body">
		<p>Vink de gebouwen aan:</p>
		
		<div id="preserved-buildings-div" class="field"></div>
		
		<div class="container-compact">
			<button id="confirm-demolish-button" class="button-2" type="button">
				Bevestigen
			</button>
		</div>
	</div>
</div>

<div id="construct-window" class="offcanvas offcanvas-start" 
	 data-bs-backdrop="true" data-bs-scroll="false" tabindex="-1">
	<div class="offcanvas-header">
		<h2>Nieuw gebouw plaatsen</h2>
		
		<button class="btn-close" type="button" data-bs-dismiss="offcanvas"></button>
	</div>
	
	<div class="offcanvas-body">
		<div class="field">
			<label for="new-building-select" class="form-label">
				Kies een gebouw:
			</label>
			<select id="new-building-select" class="form-select" required></select>
		</div>
		
		<div class="field">
			<label for="size-select" class="form-label">
				Kies een grootte:
			</label>
			<select id="size-select" class="form-select" required></select>
		</div>
		
		<div class="field">
			<label for="building-name-input" class="form-label">
				Naam van het nieuwe gebouw:
			</label>
			<input id="building-name-input" class="form-control" type="text" required>
		</div>
		
		<p id="building-name-error" class="error"></p>
		
		<div class="container-compact">
			<button id="confirm-construct-button" class="button-2" type="button">
				Bevestigen
			</button>
		</div>
	</div>
</div>

<!------------------------------------------------------------------------------------------------>

<script type="module">
//-----------------------------------------------------------------------------------------------//
import { turn } from '/js/turn-flow.js';
//-----------------------------------------------------------------------------------------------//
document.addEventListener('DOMContentLoaded', () => {
	turn.page.initialize();
});
//-----------------------------------------------------------------------------------------------//
turn.page.load = function() {
	loadPageData();
	cachePageElements();
	createOffcanvasObjects();
	
	const data = turn.page.data;
	const elements = turn.page.elements;
	
	// Add event listeners
	elements.confirmDemolish.addEventListener('click', handleConfirmDemolish);
	elements.confirmConstruct.addEventListener('click', handleConfirmConstruct);
	elements.buildingName.addEventListener('input', handleBuildingNameInput);
	
	// Populate select elements
	turn.page.populateSelect(elements.newBuilding, data.constructibleBuildings, 'type');
	turn.page.populateSelect(elements.size, data.sizes);
	
	
	
	
	
	
	
	
	
	
	// Get actions
	turn.page.actions = JSON.parse(localStorage.getItem(`turn.page${turn.page.index}.actions`));
	if (!turn.page.actions) {
		turn.page.actions = {
			demolish: [],
			construct: []
		};
	}
	const actions = turn.page.actions;
	
	// Get game state
	const characterState = JSON.parse(localStorage.getItem(`turn.characterState`));
	const buildings = JSON.parse(localStorage.getItem(`turn.buildings`));
	const sizes = JSON.parse(localStorage.getItem(`turn.sizes`));
	
	// Get input elements
	turn.page.elements = {
		demolishWindow: document.getElementById('demolish-window'),
		constructWindow: document.getElementById('construct-window'),
		openDemolishWindow: document.getElementById('open-demolish-window-button'),
		openConstructWindow: document.getElementById('open-construct-window-button'),
		confirmDemolish: document.getElementById('confirm-demolish-button'),
		confirmConstruct: document.getElementById('confirm-construct-button'),
		demolishedBuildings: document.getElementById('demolished-buildings-ul'),
		newConstructionSites: document.getElementById('new-construction-sites-ul'),
		preservedBuildings: document.getElementById('preserved-buildings-div'),
		freeTiles: document.getElementById('free-tiles-span'),
		newBuilding: document.getElementById('new-building-select'),
		size: document.getElementById('size-select'),
		buildingName: document.getElementById('building-name-input'),
		buildingNameError: document.getElementById('building-name-error')
	};
	const elements = turn.page.elements;
	
	// Get offcanvas objects
	turn.page.demolishOffcanvas = new bootstrap.Offcanvas(elements.demolishWindow);
	turn.page.constructOffcanvas = new bootstrap.Offcanvas(elements.constructWindow);
	
	// Add event listeners
	elements.confirmDemolish.addEventListener('click', handleConfirmDemolish);
	elements.confirmConstruct.addEventListener('click', handleConfirmConstruct);
	elements.buildingName.addEventListener('input', handleBuildingNameInput);
	
	// Write to elements
	const constructibleBuildings = buildings.filter(b => b.isConstructible);
	turn.page.populateSelect(elements.newBuilding, constructibleBuildings, 'type');
	turn.page.populateSelect(elements.size, sizes);
	
	// Write to data object
	let freeTiles = characterState.ownedTiles;
	
	const ownedConstructionSites = characterState.ownedConstructionSites;
	
	const ownedBuildings = characterState.ownedBuildings.map(ob => {
		const building = buildings.find(b => b.id === ob.buildingId);
		const isDemolished = actions.demolish.some(d => d.id === ob.id);
		
		let type;
		let progress;
		if (building.slug === 'construction-site') {
			const constructionSite = ownedConstructionSites.find(ocs => ocs.id === ob.id);
			const newBuilding = buildings.find(b => b.id === constructionSite.buildingId);
			type = newBuilding.type;
			progress = `${constructionSite.bricksUsed}/${constructionSite.bricksNeeded}`;
		} else {
			type = building.type;
		}
		
		const label = getBuildingLabel({ name: ob.name,
										 type,
										 size: ob.size,
										 progress });
		
		if (!isDemolished) freeTiles -= ob.size;
		
		return {
			id: ob.id,
			isDemolished,
			size: ob.size,
			label
		};
	});
	
	const newConstructionSites = actions.construct.map(c => {
		const building = buildings.find(b => b.id === c.buildingId);
		const label = getBuildingLabel({ name: c.name,
										 type: building.type,
										 size: c.size });
		
		freeTiles -= c.size;
		
		return {
			buildingId: c.buildingId,
			name: c.name,
			size: c.size,
			label
		};
	});
	
	turn.page.data = {
		freeTiles,
		ownedBuildings,
		newConstructionSites,
		buildings,
		sizes
	};
}
//-----------------------------------------------------------------------------------------------//
turn.page.save = function() {
	const data = turn.page.data;
	
	const phase = {
		demolish: [],
		construct: []
	};
	
	// Demolish
	data.demolishableBuildings.forEach(ob => {
		if (ob.isDemolished) {
			phase.demolish.push(ob.id);
		}
	});
	
	// Construct
	data.newConstructionSites.forEach(ncs => {
		phase.construct.push({
			characterBuildingId: ncs.characterBuildingId,
			buildingId: ncs.buildingId,
			size: ncs.size
		});
	});
	
	// Save to local storage
	localStorage.setItem(`turn.manageBuildings`, JSON.stringify(phase));
}
//-----------------------------------------------------------------------------------------------//
turn.page.updateUI = function() {
	renderDemolishList();
	renderConstructList();
	renderFreeTiles();
	
	/*const elements = turn.page.elements;
	
	// Enable/disable all elements
	elements.openDemolishWindow.disabled = turn.page.disabled;
	elements.openConstructWindow.disabled = turn.page.disabled;
	elements.demolish.querySelectorAll('li').forEach(li => {
		const button = li.querySelector('button.btn-close');
		if (button) button.disabled = turn.page.disabled;
	});
	elements.construct.querySelectorAll('li').forEach(li => {
		const button = li.querySelector('button.btn-close');
		button.disabled = turn.page.disabled;
	});*/
	
	// Enable next button (always)
	turn.page.setNextDisabled(false);
}
//-----------------------------------------------------------------------------------------------//
function loadPageData() {
	// Get actions
	turn.page.actions = JSON.parse(localStorage.getItem(`turn.page${turn.page.index}.actions`));
	if (!turn.page.actions) {
		turn.page.actions = {
			demolish: [],
			construct: []
		};
	}
	
	
	const phase = JSON.parse(localStorage.getItem(`turn.manageBuildings`));
	const buildings = JSON.parse(localStorage.getItem(`turn.static.buildings`));
	const buildingSizes = JSON.parse(localStorage.getItem(`turn.static.buildingSizes`));
	const ownedTiles = JSON.parse(localStorage.getItem(`turn.characterState.ownedTiles`));
	const ownedBuildings = JSON.parse(localStorage.getItem(`turn.characterState.ownedBuildings`));
	const ownedReservedBuildings = JSON.parse(localStorage.getItem(`turn.characterState.ownedReservedBuildings`));
	const ownedConstructionSites = JSON.parse(localStorage.getItem(`turn.characterState.ownedConstructionSites`));
	
	let freeTiles = ownedTiles;
	
	const constructibleBuildings = buildings.filter(b => b.isConstructible);
	
	const demolishableBuildings = ownedBuildings.map(ob => {
		const building = buildings.find(b => b.id === ob.buildingId);
		const isDemolished = phase.demolish.some(d => d.id === ob.id);
		
		let type;
		let progress;
		if (building.slug === 'construction-site') {
			const constructionSite = ownedConstructionSites.find(ocs => ocs.id === ob.id);
			const newBuilding = buildings.find(b => b.id === constructionSite.buildingId);
			type = newBuilding.type;
			progress = `${constructionSite.bricksUsed}/${constructionSite.bricksNeeded}`;
		} else {
			type = building.type;
		}
		
		const label = getBuildingLabel({ name: ob.name,
										 type,
										 size: ob.size,
										 progress });
		
		if (!isDemolished) freeTiles -= ob.size;
		
		return {
			id: ob.id,
			isDemolished,
			size: ob.size,
			label
		};
	});
	
	const newConstructionSites = phase.construct.map(c => {
		const building = buildings.find(b => b.id === c.buildingId);
		const label = getBuildingLabel({ name: c.name,
										 type: building.type,
										 size: c.size });
		
		freeTiles -= c.size;
		
		return {
			buildingId: c.buildingId,
			name: c.name,
			size: c.size,
			label
		};
	});
	
	turn.page.data = {
		freeTiles,
		ownedBuildings,
		newConstructionSites,
		buildings,
		sizes
	};
}
//-----------------------------------------------------------------------------------------------//
function cachePageElements() {
	turn.page.elements = {
		demolishWindow: document.getElementById('demolish-window'),
		constructWindow: document.getElementById('construct-window'),
		openDemolishWindow: document.getElementById('open-demolish-window-button'),
		openConstructWindow: document.getElementById('open-construct-window-button'),
		confirmDemolish: document.getElementById('confirm-demolish-button'),
		confirmConstruct: document.getElementById('confirm-construct-button'),
		demolishedBuildings: document.getElementById('demolished-buildings-ul'),
		newConstructionSites: document.getElementById('new-construction-sites-ul'),
		preservedBuildings: document.getElementById('preserved-buildings-div'),
		freeTiles: document.getElementById('free-tiles-span'),
		newBuilding: document.getElementById('new-building-select'),
		size: document.getElementById('size-select'),
		buildingName: document.getElementById('building-name-input'),
		buildingNameError: document.getElementById('building-name-error')
	};
}
//-----------------------------------------------------------------------------------------------//
function createOffcanvasObjects() {
	turn.page.demolishOffcanvas = new bootstrap.Offcanvas(elements.demolishWindow);
	turn.page.constructOffcanvas = new bootstrap.Offcanvas(elements.constructWindow);
}


function getBuildingLabel({ name,
							type,
							size,
							progress = null }) {
	const unit = size === 1 ? 'tegel' : 'tegels';
	const progressText = progress ? `, ${progress} voltooid` : '';
	return `${name} <small>(${type}, ${size} ${unit}${progressText})</small>`;

}
//-----------------------------------------------------------------------------------------------//

function handleConfirmDemolish() {
	// Write from elements to data object
	const elements = turn.page.elements;
	const data = turn.page.data;

	const checkboxes = elements.preservedBuildings.querySelectorAll('input[type="checkbox"]');

	checkboxes.forEach(checkbox => {
		if (checkbox.checked) {
			const buildingId = Number(checkbox.dataset.buildingId);
			const building = data.ownedBuildings.find(b => b.id === buildingId);
			building.isDemolished = checkbox.checked;

			data.freeTiles += building.size;
		}
	});
	
	// Update UI
	turn.page.updateUI();
	
	// Close offcanvas
	turn.page.demolishOffcanvas.hide();
}
//-----------------------------------------------------------------------------------------------//
async function canConfirmConstruct() {	
	const elements = turn.page.elements;
	const buildingName = elements.buildingName.value;

	try {
		const res = await fetch('/game/turn/reserve-building-name', {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify({ characterBuildingName })
		});

		const json = await res.json();
		if (!json.success) {
			elements.buildingNameError.textContent = json.error.message;
			return false;
		}

		const characterBuildingId = json.data.characterBuildingId;
		
		
		
		return true;
	} catch (err) {
		console.error(err);
		return false;
	}
}
//-----------------------------------------------------------------------------------------------//
function handleNewBuildingChange() {
	// Set available sizes of the chosen new building
	const elements = turn.page.elements;
	const data = turn.page.data;
	
	const newBuildingId = Number(elements.newBuilding.value);
	const newBuilding = data.buildings.find(b => b.id === newBuildingId);
	
	elements.sizeFactor.innerHTML = '';
	data.sizeFactors.forEach(sizeFactor => {
		const size = newBuilding.baseSize * sizeFactor;
		const unit = (size === 1 ? 'tegel' : 'tegels');
		
		const option = document.createElement('option');
		option.value = sizeFactor;
		option.textContent = `${size} ${unit}`;
		option.disabled = (size > data.freeTiles);
		elements.sizeFactor.appendChild(option);
	});
	elements.sizeFactor.disabled = false;
	
	// Update local UI
	updateConstructUI();
}
//-----------------------------------------------------------------------------------------------//
function handleBuildingNameInput() {
	const elements = turn.page.elements;
	const data = turn.page.data;
	
	// Clear previous error
	elements.buildingNameError.textContent = '';
	
	// Check if the name is valid	
	const nameInput = elements.buildingName;
	const name = nameInput.value;
	const minLength = 2;
	const maxLength = 32;
	const regex = /^[A-Za-z0-9√Ä-√ñ√ò-√∂√∏-√øƒÄ-≈æ?!.]+(?:[ '-][A-Za-z0-9√Ä-√ñ√ò-√∂√∏-√øƒÄ-≈æ?!.]+)*$/;

	if (name.length < minLength) {
		nameInput.setCustomValidity(`Minimaal ${minLength} tekens vereist.`);
	} else if (name.length > maxLength) {
		nameInput.setCustomValidity(`Maximaal ${maxLength} tekens toegestaan.`);
	} else if (!regex.test(name)) {
		nameInput.setCustomValidity('Dit is geen geldige naam.');
	} else {
		nameInput.setCustomValidity('');
	}
	nameInput.reportValidity();
	
	// Check if the user has already chosen this name
	const nameConflict = data.newConstructionSites.some(
		b => b.name.toLowerCase() === name.toLowerCase()
	);
    if (nameConflict) {
        elements.buildingNameError.textContent = 'Deze naam heb je al gebruikt.';
    }
	
	// Update offcanvas UI
	updateConstructUI();
}
//-----------------------------------------------------------------------------------------------//
async function handleConfirmConstruct() {
	const elements = turn.page.elements;
	const characterBuildingName = elements.buildingName.value;

	// Check if this name is already taken
	try {
		const res = await fetch('/game/turn/reserve-building-name', {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify({ characterBuildingName })
		});

		const json = await res.json();
		if (!json.success) {
			elements.buildingNameError.textContent = json.error.message;
			return;
		}
	} catch (err) {
		console.error(err);
		return;
	}
	
	
	
	const characterBuildingId = json.data.characterBuildingId;
	
	
	
	
	// Write from elements to data object
	const data = turn.page.data;
	
	const newBuildingId = Number(elements.newBuilding.value);
	const newBuilding = data.buildings.find(b => b.id === newBuildingId);
	const name = elements.buildingName.value;
	const size = Number(elements.size.value);
	const label = getBuildingLabel({ name,
									 type: newBuilding.type,
									 size });
	
	data.newConstructionSites.push({
		id: newBuildingId,
		name,
		size,
		label
	});
	
	data.freeTiles -= size;
	
	// Update UI
	turn.page.updateUI();
	
	// Close offcanvas
	turn.page.constructOffcanvas.hide();
}

//-----------------------------------------------------------------------------------------------//
function updateConstructUI() {
	const elements = turn.page.elements;
	
	if (elements.newBuilding.value === '' ||
		elements.buildingName.value === '' ||
		!elements.buildingName.checkValidity()) {
		elements.confirmConstruct.disabled = true;
	} else {
		elements.confirmConstruct.disabled = false;
	}
}
//-----------------------------------------------------------------------------------------------//
function renderDemolishList() {
	// Write from data object to elements
	const data = turn.page.data;
	const elements = turn.page.elements;
	
	elements.demolishedBuildings.innerHTML = '';
	elements.preservedBuildings.innerHTML = '';
	
	data.ownedBuildings.forEach(ob => {
		if (ob.isDemolished) {
			// Add to demolished buildings list
			const li = document.createElement('li');
			li.className = 'list-item-justify';
			li.dataset.buildingId = ob.id;
			
			const span = document.createElement('span');
			span.innerHTML = ob.label;
			li.appendChild(span);
			
			if (ob.size <= data.freeTiles) {
				const button = document.createElement('button');
				button.type = 'button';
				button.classList.add('btn-close');
				button.disabled = turn.page.disabled;
				button.addEventListener('click', () => {
					ob.isDemolished = false;
					data.freeTiles -= ob.size;
					turn.page.updateUI();
				});
				li.appendChild(button);
			}

			elements.demolishedBuildings.appendChild(li);
		} else {
			// Add to preserved buildings list
			const div = document.createElement('div');
			div.className = 'form-check';
			
			const input = document.createElement('input');
			input.id = 'demolish_' + ob.id;
			input.className = 'form-check-input';
			input.type = 'checkbox';
			input.dataset.buildingId = ob.id;
			div.appendChild(input);
			
			const label = document.createElement('label');
			label.htmlFor = input.id;
			label.className = 'form-check-label';
			label.innerHTML = ob.label;
			div.appendChild(label);
			
			elements.preservedBuildings.appendChild(div);
		}
	});
	
	// Show/hide demolished buildings list
	if (elements.demolishedBuildings.children.length === 0) {
		elements.demolishedBuildings.classList.add('d-none');
	} else {
		elements.demolishedBuildings.classList.remove('d-none');
	}
	
	// Enable/disable demolish window
	const areAllBuildingsDemolished = data.ownedBuildings.every(ob => ob.isDemolished);
	elements.openDemolishWindow.disabled = areAllBuildingsDemolished || turn.page.disabled;
}
//-----------------------------------------------------------------------------------------------//
function renderConstructList() {
	// Write from data object to elements
	const data = turn.page.data;
	const elements = turn.page.elements;
	
	elements.newConstructionSites.innerHTML = '';
	
	data.newConstructionSites.forEach((ncs, index) => {
		// Add to new construction sites list
		const li = document.createElement('li');
		li.className = 'list-item-justify';
		li.dataset.buildingId = 'nb_' + index; // temporary id
		
		const span = document.createElement('span');
		span.innerHTML = ncs.label;
		li.appendChild(span);
		
		const button = document.createElement('button');
		button.type = 'button';
		button.classList.add('btn-close');
		button.disabled = turn.page.disabled;
		button.addEventListener('click', () => {
			data.newConstructionSites.splice(index, 1);
			data.freeTiles += ncs.size;
			turn.page.updateUI();
		});
		li.appendChild(button);
		
		elements.newConstructionSites.appendChild(li);
	});
	
	elements.newBuilding.value = '';
	elements.buildingName.value = '';
	elements.size.value = '';
	for (const option of elements.size.options) {
		const tiles = Number(option.value);
		option.disabled = tiles > data.freeTiles;
	}
	
	// Update offcanvas UI
	updateConstructUI();
	
	// Show/hide new construction sites list
	if (elements.newConstructionSites.children.length === 0) {
		elements.newConstructionSites.classList.add('d-none');
	} else {
		elements.newConstructionSites.classList.remove('d-none');
	}
	
	// Enable/disable construct window
	const areAllTilesOccupied = (data.freeTiles === 0);
	elements.openConstructWindow.disabled = areAllTilesOccupied || turn.page.disabled;
}
//-----------------------------------------------------------------------------------------------//
function renderFreeTiles() {
	// Write from data object to elements
	const data = turn.page.data;
	const elements = turn.page.elements;
	
	elements.freeTiles.textContent = data.freeTiles;
}
//-----------------------------------------------------------------------------------------------//

</script>